;; Hybrid: Rule 110 + arithmetic at domain boundaries
;;
;; Base: Rule 110 per-bit computation (Class IV dynamics)
;; At cells where neighbors differ by >3 bits, switch to arithmetic
;; addition of neighbors. This creates STRUCTURED coupling — cross-bit
;; interaction localized at domain boundaries.
;;
;; Prediction: Class IV bitplane dynamics with spatially localized coupling.

{:meta {:id :hybrid-110-boundary
        :description "Rule 110 base + arithmetic addition at domain boundaries"
        :formula "if hamming(L,R)>3 then (L+R)%256 else Rule110(L,C,R)"
        :coupling-type :structured}
 :diagram
 {:nodes
  [;; Context
   {:id :pred :component :context-pred}
   {:id :self :component :context-self}
   {:id :succ :component :context-succ}

   ;; Rule 110 path: (C OR R) AND NOT(L AND C AND R)
   {:id :or-cr :component :bit-or}
   {:id :and-lc :component :bit-and}
   {:id :and-lcr :component :bit-and}
   {:id :not-lcr :component :bit-not}
   {:id :r110 :component :bit-and}

   ;; Arithmetic path: (L + R) mod 256
   {:id :arith :component :sigil-add-mod}

   ;; Boundary detection: hamming(L, R) > 3
   {:id :dist :component :distance}
   {:id :boundary :component :int-gt?}

   ;; Gate: boundary → arithmetic, else → Rule 110
   {:id :gate :component :if-then-else-sigil}

   {:id :output :component :output-sigil}]

  :output :output

  :edges
  [;; Rule 110 wiring
   {:from :self :to :or-cr :to-port :a}
   {:from :succ :to :or-cr :to-port :b}
   {:from :pred :to :and-lc :to-port :a}
   {:from :self :to :and-lc :to-port :b}
   {:from :and-lc :to :and-lcr :to-port :a}
   {:from :succ :to :and-lcr :to-port :b}
   {:from :and-lcr :to :not-lcr}
   {:from :or-cr :to :r110 :to-port :a}
   {:from :not-lcr :to :r110 :to-port :b}

   ;; Arithmetic path
   {:from :pred :to :arith :to-port :a}
   {:from :succ :to :arith :to-port :b}

   ;; Boundary detection
   {:from :pred :to :dist :to-port :a}
   {:from :succ :to :dist :to-port :b}
   {:from :dist :from-port :dist :to :boundary :to-port :a}
   {:value 3 :value-type :int :to :boundary :to-port :b}

   ;; Gate
   {:from :boundary :from-port :above :to :gate :to-port :cond}
   {:from :arith :from-port :result :to :gate :to-port :then}
   {:from :r110 :from-port :result :to :gate :to-port :else}

   {:from :gate :from-port :result :to :output}]}}
