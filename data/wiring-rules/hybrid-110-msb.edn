;; Hybrid: Rule 110 + arithmetic when MSB of self = 1
;;
;; base   = Rule110(L, C, R)
;; arith  = (base + C) mod 256
;; msb?   = bit-test(C, 7)          <- true when cell value >= 128
;; result = if msb? then arith else base
;;
;; MSB divides sigil space cleanly in half. Since Rule 110 creates domain
;; structure on each bitplane, the MSB condition correlates with actual
;; domain boundaries — the key insight the Hamming-based conditions missed.
;;
;; Prediction: structured coupling localized to MSB=1 regions.

{:meta {:id :hybrid-110-msb
        :description "Rule 110 + arithmetic addition when MSB of self is 1"
        :formula "if bit7(C)=1 then (Rule110(L,C,R)+C)%256 else Rule110(L,C,R)"
        :coupling-type :bitplane-conditional}
 :diagram
 {:nodes
  [{:id :pred :component :context-pred}
   {:id :self :component :context-self}
   {:id :succ :component :context-succ}

   ;; Rule 110: (C OR R) AND NOT(L AND C AND R)
   {:id :or-cr :component :bit-or}
   {:id :and-lc :component :bit-and}
   {:id :and-lcr :component :bit-and}
   {:id :not-lcr :component :bit-not}
   {:id :r110 :component :bit-and}

   ;; Arithmetic path: (R110 + C) mod 256
   {:id :arith :component :sigil-add-mod}

   ;; MSB condition: bit-test(C, 7)
   {:id :msb :component :bit-test}

   ;; Gate: MSB → arithmetic, else → Rule 110
   {:id :gate :component :if-then-else-sigil}

   {:id :output :component :output-sigil}]

  :output :output

  :edges
  [;; Rule 110 wiring
   {:from :self :to :or-cr :to-port :a}
   {:from :succ :to :or-cr :to-port :b}
   {:from :pred :to :and-lc :to-port :a}
   {:from :self :to :and-lc :to-port :b}
   {:from :and-lc :to :and-lcr :to-port :a}
   {:from :succ :to :and-lcr :to-port :b}
   {:from :and-lcr :to :not-lcr}
   {:from :or-cr :to :r110 :to-port :a}
   {:from :not-lcr :to :r110 :to-port :b}

   ;; Arithmetic path: R110 + self
   {:from :r110 :from-port :result :to :arith :to-port :a}
   {:from :self :to :arith :to-port :b}

   ;; MSB condition
   {:from :self :to :msb :to-port :sigil}
   {:value 7 :value-type :int :to :msb :to-port :index}

   ;; Gate
   {:from :msb :from-port :bit :to :gate :to-port :cond}
   {:from :arith :from-port :result :to :gate :to-port :then}
   {:from :r110 :from-port :result :to :gate :to-port :else}

   {:from :gate :from-port :result :to :output}]}}
